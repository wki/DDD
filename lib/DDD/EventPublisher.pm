package DDD::EventPublisher;
use 5.010;
use Moose;
use namespace::autoclean;

with 'DDD::Role::Domain';

=head1 NAME

DDD::EventPublisher - a simple PubSub implementation

=head1 SYNOPSIS

=head1 DESCRIPTION

not needed directly

=head1 ATTRIBUTES

=cut

has _listeners => (
    traits  => ['Array'],
    is      => 'rw',
    isa     => 'ArrayRef', # of { event, target, method }
    default => sub { [] },
    handles => {
        _add_listener  => 'push',
        _all_listeners => 'elements',
        _nr_listeners  => 'count',
        _first_index   => 'first_index',
        _delete        => 'delete',
    }
);

has _event_store => (
    traits => ['Array'],
    is     => 'rw',
    isa    => 'ArrayRef',
    default => sub { [] },
    handles => {
        publish      => 'push',
        clear_events => 'clear', # needed for tests
        _next_event  => 'shift',
        _nr_events   => 'count',
        _all_events  => 'elements',
    },
);

=head1 METHODS

=cut

after publish => sub {
    my ($self, $event) = @_;
    
    $self->log_debug(publish => ref $event);
};

=head2 instance

implement a singleton

=cut

sub instance {
    my ($class, @args) = @_;

    state $instance = $class->new(@args);

    return $instance;
}

=head2 add_listener ( $event, $target, $method )

adds the target object as a listener wanting to capture a given event.

=cut

sub add_listener {
    my ($self, $event, $target, $method) = @_;
    
    my $listen_for = $event || '-all-';
    
    $self->log_debug(subscribe => "Adding listener: $listen_for ==> ${\ref $target}($method)");
    $self->_add_listener(
        { target => $target, event => $event, method => $method }
    );
}

=head2 remove_listener ( $event, $target [, $method ] )

removes a listener. Only event and target are evaluated, method is ignored.

=cut

sub remove_listener {
    my ($self, $event, $target) = @_;
    
    my $index = $self->_first_index( sub {
        $_->{event} eq $event && $_->{target} eq $target
    });
    
    $self->_delete($index) if $index >= 0;
}

=head2 has_event ( $event )

returns true if there is an event of type $event. Useful for testing.

=cut

sub has_event {
    my ($self, $event) = @_;
    
    return grep { ref($_) =~ m{\b $event \z}xms } $self->_all_events;
}

=head2 process_events

process all saved events

### FIXME: how can we protect against overruns generated by events published
###        during processing?

=cut

sub process_events {
    my $self = shift;
    
    while (my $event = $self->_next_event) {
        $self->process_event($event);
    }
}

=head2 process_event ( $event )

process a single event

=cut

sub process_event {
    my ($self, $event_object) = @_;
    
    my $event_name = ref $event_object;
    $event_name =~ s{\A .* ::}{}xms;
        
    foreach my $listener ($self->_all_listeners) {
        my ($event, $target, $method) = @$listener{qw(event target method)};
        next if $event && $event ne $event_name;
        
        $self->log_debug(process => "$event_name -> ${\ref $target}($method)");

        $target->$method($event_object);
    }
}

__PACKAGE__->meta->make_immutable;
1;

=head1 AUTHOR

Wolfgang Kinkeldei, E<lt>wolfgang@kinkeldei.deE<gt>

=head1 LICENSE

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
